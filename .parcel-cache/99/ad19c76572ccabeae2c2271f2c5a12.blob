const cheerio = require('cheerio');
const axios = require('axios')
//const puppeteer = require('puppeteer');

const URL = "https://medium.com/swlh/my-software-engineer-roadmap-2fb0c02b8a08"

const fetchHTML = async (url) => {
    const request = await axios.get(url);
    return request.data;
}

(async () => {
    let orderedText = [];
    const content = await fetchHTML(URL);
    const $ = cheerio.load(content);

    const tag = { "h1": [], "h2": [], "p": [] };
    $('section > div > div').each((i, elem) => {

        $(elem).find('h1').each((i, e) => {
            tag.h1.push($(e).text());
        })

        $(elem).find('h2').each((i, e) => {
            tag.h2.push($(e).text());
        })

        $(elem).find('p').each((i, e) => {
            tag.p.push($(e).text());
        })
    })
    const textSelector = $('section > div > div > p,h1,h3')
    textSelector.each((i, e) => {
        orderedText.push($(e).text())
    })
/*
    const objFilter = (obj) => {
        const keys = Object.keys(obj)
        switch(keys){
            case 'h1':
                return 
            default:
                break;
        }
    }
*/

    const createOrderedObject = (i, current, tag) => {
        const entries = new Map
        switch(tag){
            case 'h1':
                entries.set(i, {'h1': current})
                 return Object.fromEntries(entries)
            case 'h2':
                entries.set(i, {'h2': current})
                return Object.fromEntries(entries)
            case 'p':
                entries.set(i, {'p': current})
                return Object.fromEntries(entries)
        }
    }
    let j = 0;
    const order = orderedText.reduce((prev, current) => {
        const obj = {};
        j++
        if(tag.h1.includes(current)){
            const newObject = createOrderedObject(j, current, 'h1')
            return Object.assign({...prev}, newObject)
        }
        else if (tag.h2.includes(current)){
            const newObject = createOrderedObject(j, current, 'h2')
            return Object.assign({...prev}, newObject)
        }
        else if (tag.p.includes(current)){
            const newObject = createOrderedObject(j, current, 'p')
            return Object.assign({...prev}, newObject)
        }
    }, {})
    window.ORDERED_TEXT = order
})();